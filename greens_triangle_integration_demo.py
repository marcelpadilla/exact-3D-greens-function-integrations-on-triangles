#!/usr/bin/env python3
"""
We compute analytically the Green's and its gradient and product with linear functions on a triangle T in R3.

Let x be an evaluation point, r(x,y) = |y-x| and Let h(x) be a linear function on the triangle with value 1 at the first triangle vertex and 0 on the other vertices.

We compute the following integrals 
  ‚à´ 1/r
  ‚à´ h ‚ãÖ 1/r
  ‚à´ <n, ‚àá(1/r)>
  ‚à´ h ‚ãÖ <n, ‚àá(1/r)>
  ‚à´ ‚àá(1/r)
  ‚à´ h ‚ãÖ ‚àá(1/r)
over a single triangle T in R3. 

An abitrary triangle is generated by the vertices triangle[0], triangle[1], triangle[2].
A wide selection of test evaluation points are generated.
The analytic computation is performed based on [Graglia]'s results.
The a numerical integration is performed via scipy.integrate.dblquad.
The results are compared and plotted in detail and saved into a folder in your working directory.

The test evaluation points are lines going through:
    - a point further outside of the triangle plane
    - a point in the triangle plane but not in the triangle or along an extended edge
    - a point on the extended edge of a triangle
    - a point on the extended edge of a triangle but off the other direction
    - a point in the triangle but not on an edge
    - a point on an edge but not a vertex
    - a triangle vertex (the first one, where h=1)    

The following reference was the base for the formulae in this code:
[Graglia] R. D. Graglia, "Numerical Integration of the Linear Shape Functions Times the 3-D Green's Function
or Its Gradient on a Plane Triangle," IEEE Transactions on Antennas and Propagation, 
vol. 41, no. 10, pp. 1448‚Äì1455, Oct. 1993.

The formulas have been adjusted to not require a transformation into the local triangle frame.
Additionally, an orientation dependant singularity issue on the extended edge of a triangle has been fixed.

Important note: When an evaluation point is at the boundary of the triangle, the tangential part of the gradient integrals become singular.

"""

import numpy as np
import os
import platform
import shutil
import subprocess
import textwrap
import time
import warnings

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from scipy.integrate import dblquad

# import the main function and a helper
import greens_triangle_integration

# -----------------------------------------------------------------------------
### Settings ###
line_resolution = 51
accuracy_treshold = 1e-6
target_folder = "integration_results"
# -----------------------------------------------------------------------------


def main():

    print("\n üèÅ Start üèÅ")

    # ---------------------------------------------------------------------
    # 1) Define the demo triangle
    # ---------------------------------------------------------------------

    simple_triangle = np.array([[0.0, 0, 0],
                  [1, 0, 0],
                  [0, 1, 0]])
    
    arbitrary_triangle = np.array([
        [0.0, -1.0, 1.0],
        [1.0, 0.0, 0.0],
        [-1.0, 2.5, 0.0]
    ])
    
    random_triangle = np.random.rand(3, 3)
    
    # pick a triangle
    triangle = arbitrary_triangle

    
    # ---------------------------------------------------------------------
    # 2) Define evaluation lines
    # ---------------------------------------------------------------------

    # initialize 
    n_evaluation_points = line_resolution + (1-line_resolution % 2) # make sure it is odd
    evaluation_cases = []; evaluation_lines = []
    running_parameter = np.linspace(-1, 1, n_evaluation_points)*.5
    triangle_normal = greens_triangle_integration.get_normal_from_triangle(triangle)
    evaluation_base_line = np.outer(running_parameter, triangle_normal)
    triangle_corner = triangle[0]
    triangle_edge_1 = triangle[1]-triangle[0]
    triangle_edge_2 = triangle[2]-triangle[0]
    
    # go through every evaluation case, comment out if you dont want to evaluate
    evaluation_cases.append("(1) outside of the triangle plane")
    line_center = triangle_corner + 0.3 * triangle_edge_1 + 0.3 * triangle_edge_2 + 1.5 * triangle_normal
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(2) in the triangle plane but not in the triangle or along an extended edge")
    line_center = triangle_corner + 0.6 * triangle_edge_1 + 0.5 * triangle_edge_2
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(3) on the extended edge of a triangle")
    line_center = triangle_corner + 1.1 * triangle_edge_1
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(4) on the extended edge of a triangle but off the other direction")
    line_center = triangle_corner - 0.1 * triangle_edge_1
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(5) in the triangle but not on an edge")
    line_center = triangle_corner + triangle_edge_1*0.3 + triangle_edge_2*0.2
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(6) through a point on an edge")
    line_center = triangle_corner + triangle_edge_1*0.3
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(7) through a triangle vertex")
    line_center = triangle_corner
    evaluation_lines.append(line_center + evaluation_base_line)
    
    
    

    # ---------------------------------------------------------------------
    # 3) Compute the triangle integrals (analytically + numerically)
    # ---------------------------------------------------------------------
    
    # comment in if you want to just evaluate one case
    # case_index = 0
    # evaluation_lines = [evaluation_lines[case_index]]
    # evaluation_cases = [evaluation_cases[case_index]]
    
    open_clean_folder(target_folder)

    # Loop over all cases
    for i in range(len(evaluation_lines)):
        
        # read
        evaluation_case = evaluation_cases[i]
        evaluation_line = evaluation_lines[i]
        print("\nEvaluating "+ evaluation_case)
        
        # analytic integration
        print("Analytic  integration...", end=''); start_time = time.perf_counter()
        
        # compute values of interest
        values_of_interest = ['G', 'h_G', 'n_grad_G', 'h_n_grad_G', 'grad_G', 'h_grad_G']
        integration_results = greens_triangle_integration.integrate(evaluation_line, triangle, values_of_interest)
        Int_G, Int_h_G, Int_n_grad_G, Int_h_n_grad_G, Int_grad_G, Int_h_grad_G = [integration_results[key] for key in values_of_interest]
        
        run_time_analytic = time.perf_counter() - start_time; print(f" {run_time_analytic:.2e} seconds")
        
        # numerical integration
        Int_num_G, Int_num_h_G, Int_num_n_grad_G, I_num_h_n_grad_G, Int_num_grad_G, Int_num_h_grad_G, run_time_numerical = greens_numeric_integration(evaluation_line, triangle)
        
        # Analyze results
        results_analytical = [Int_G, Int_h_G, Int_grad_G, Int_h_grad_G, Int_n_grad_G, Int_h_n_grad_G, run_time_analytic]
        results_numerical = [Int_num_G, Int_num_h_G, Int_num_n_grad_G, I_num_h_n_grad_G, Int_num_grad_G, Int_num_h_grad_G, run_time_numerical]
        analyze_results(results_analytical, results_numerical, evaluation_line, triangle, running_parameter, evaluation_case)
        

    print("\n üö© End üö© \n")

# -----------------------------------------------------------------------------
# Numerical integration
# -----------------------------------------------------------------------------

# wrapper function to call and time all numerical integrals
def greens_numeric_integration(evaluation_points,triangle):
    
    start_time = time.perf_counter()
    print("Numerical integration...", end='')
    
    I_num = greens_numeric_integration_G(evaluation_points, triangle)
    I_num_linear = greens_numeric_integration_h_G(evaluation_points, triangle)
    I_num_grad = greens_numeric_integration_grad_G(evaluation_points, triangle)
    I_num_grad_linear = greens_numeric_integration_h_grad_G(evaluation_points, triangle)
    I_num_n_grad = greens_numeric_integration_n_grad_G(evaluation_points, triangle)
    I_num_n_grad_linear = greens_numeric_integration_h_n_grad_G(evaluation_points, triangle)
    
    time_passed = time.perf_counter() - start_time
    print(f" {time_passed:.2e} seconds")
    
    return I_num, I_num_linear, I_num_grad, I_num_grad_linear, I_num_n_grad, I_num_n_grad_linear, time_passed

def greens_numeric_integration_G(evaluation_points, triangle):
    """
    Numerically integrates 1/|y - x| over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """

    npt = evaluation_points.shape[0]
    I_const = np.zeros(npt)

    # Edges
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    Jac = np.linalg.norm(np.cross(v1, v2))

    for i in range(npt):
        q = evaluation_points[i]

        def integrand_1overr(v, u):
            Y = triangle[0] + u * v1 + v * v2
            r_vec = q - Y
            r = np.linalg.norm(r_vec)
            return Jac / r

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val_const, _ = dblquad(
                integrand_1overr,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
        I_const[i] = val_const

    return I_const

def greens_numeric_integration_h_G(evaluation_points, triangle):
    """
    Numerically integrates h ‚ãÖ 1/|y - x| over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """
    # for testing h0, h1, h2. h0 is default
    # triangle = triangle[[1, 2, 0]] # h1
    # triangle = triangle[[2, 0, 1]] # h2

    npt = evaluation_points.shape[0]
    I_lin = np.zeros(npt)
    
    # Edges as before
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    Jac = np.linalg.norm(np.cross(v1, v2))

    for i in range(npt):
        q = evaluation_points[i]

        def integrand_1overr(v, u):
            Y = triangle[0] + u * v1 + v * v2
            r_vec = q - Y
            r = np.linalg.norm(r_vec)
            shape0 = 1.0 - u - v  # the shape function for node 0
            return (Jac * shape0) / r

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val_lin, _ = dblquad(
                integrand_1overr,
                0.0, 1.0,           
                lambda u: 0.0,      
                lambda u: 1.0 - u   
            )
        I_lin[i] = val_lin

    return I_lin

def greens_numeric_integration_grad_G(evaluation_points, triangle):
    """
    Numerically integrates ‚àá( 1/|y - x| ) over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """
    npt = evaluation_points.shape[0]

    # Prepare the output array for the 3 components
    I_grad = np.zeros((npt, 3))

    # Precompute vectors for parameterization
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    # The Jacobian factor for surface area
    Jac = np.linalg.norm(np.cross(v1, v2))
    
    # Loop over each observer point
    for i in range(npt):
        q = evaluation_points[i]

        def integrand_grad(v, u):
            Y = triangle[0] + u * v1 + v * v2
            r_vec = q - Y
            r = np.linalg.norm(r_vec)
            return -(r_vec / r**3) * Jac 

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val, _ = dblquad(
                lambda v, u: integrand_grad(v, u)[0],
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            I_grad[i, 0] = val

            val, _ = dblquad(
                lambda v, u: integrand_grad(v, u)[1],
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            I_grad[i, 1] = val

            val, _ = dblquad(
                lambda v, u: integrand_grad(v, u)[2],
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            I_grad[i, 2] = val

    return I_grad

def greens_numeric_integration_h_grad_G(evaluation_points, triangle):
    """
    Numerically integrates h ‚ãÖ ‚àá( 1/|y - x| ) over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """
    npt = evaluation_points.shape[0]

    # for testing h0, h1, h2. h0 is default
    # triangle = triangle[[1, 2, 0]] # h1
    # triangle = triangle[[2, 0, 1]] # h2

    # Prepare the output array for the 3 components
    I_grad = np.zeros((npt, 3))
    
    # Precompute vectors for parameterization
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    # The surface area factor
    Jac = np.linalg.norm(np.cross(v1, v2))

    for i in range(npt):
        q = evaluation_points[i]

        def integrand_grad(v, u):
            Y = triangle[0] + u * v1 + v * v2
            r_vec = q - Y
            r = np.linalg.norm(r_vec)
            shape0 = 1.0 - u - v
            return shape0 * (-(r_vec / r**3)) * Jac

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val, _ = dblquad(
                lambda v, u: integrand_grad(v, u)[0],
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            I_grad[i, 0] = val

            val, _ = dblquad(
                lambda v, u: integrand_grad(v, u)[1],
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            I_grad[i, 1] = val

            val, _ = dblquad(
                lambda v, u: integrand_grad(v, u)[2],
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            I_grad[i, 2] = val

    return I_grad

def greens_numeric_integration_n_grad_G(evaluation_points, triangle):
    """
    Numerically integrates < n , ‚àá( 1/|y - x| ) > over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """

    npt = evaluation_points.shape[0]

    # Prepare the output array
    I_grad_dot_n = np.zeros(npt)

    # Precompute vectors for parameterization
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    # The Jacobian factor for surface area
    Jac = np.linalg.norm(np.cross(v1, v2))

    # Get the normal vector of the triangle
    normal = greens_triangle_integration.get_normal_from_triangle(triangle)

    # Loop over each observer point
    for i in range(npt):
        q = evaluation_points[i]

        def integrand(v, u):
            Y = triangle[0] + u * v1 + v * v2
            r_vec = q - Y
            r = np.linalg.norm(r_vec)
            grad = r_vec / r**3
            return -np.dot(normal, grad) * Jac

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val, _ = dblquad(
                integrand,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
        I_grad_dot_n[i] = val

    return I_grad_dot_n

def greens_numeric_integration_h_n_grad_G(evaluation_points, triangle):
    """
    Numerically integrates h ‚ãÖ < n , ‚àá( 1/|y - x| ) > over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """
    # for testing h0, h1, h2. h0 is default
    # triangle = triangle[[1, 2, 0]] # h1
    # triangle = triangle[[2, 0, 1]] # h2
    
    npt = evaluation_points.shape[0]
    I_grad_dot_n = np.zeros(npt)

    # -----------------------------------------------------
    # 1) Parameterization / geometry setup
    # -----------------------------------------------------

    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    # Triangle area scaling factor = ||v1 x v2||
    Jac = np.linalg.norm(np.cross(v1, v2))
    normal = greens_triangle_integration.get_normal_from_triangle(triangle)


    # -----------------------------------------------------
    # 2) Integration loop over each observer point
    # -----------------------------------------------------
    for i in range(npt):
        q = evaluation_points[i]

        def integrand_1overr_dot_n(v, u):
            Y = triangle[0] + u * v1 + v * v2
            r_vec = q - Y
            r = np.linalg.norm(r_vec)
            grad_dot_n = -np.dot(r_vec, normal) / (r**3)
            shape0 = 1 - u - v
            return grad_dot_n * shape0 * Jac

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val, _ = dblquad(
                integrand_1overr_dot_n,
                0.0, 1.0,                # u goes 0..1
                lambda u: 0.0,           # v min
                lambda u: 1.0 - u        # v max
            )

        I_grad_dot_n[i] = val

    return I_grad_dot_n

# -----------------------------------------------------------------------------
# Analyzing functions
# -----------------------------------------------------------------------------

# Compute errors and plot results comparing the analytical and numerical integrals
def analyze_results(results_analytical, results_numerical, evaluation_line, triangle, running_parameter, evaluation_case):
    
    # read
    Int_G, Int_h_G, Int_grad_G, Int_h_grad_G, Int_n_grad_G, Int_h_n_grad_G, time_analytical = results_analytical
    Int_num_G, Int_num_h_G, Int_num_grad_G, I_num_h_grad_G, Int_num_n_grad_G, Int_num_h_n_grad_G, time_numerical = results_numerical
    
    # read only the h0 linear function component of the results with the 3 components
    Int_h_G = Int_h_G[:, 0]
    Int_h_grad_G = Int_h_grad_G[:, : , 0]
    Int_h_n_grad_G = Int_h_n_grad_G[:, 0]
    
    # error measures
    error_threshhold = accuracy_treshold*np.min([np.linalg.norm(triangle[i] - triangle[(i+1) % 3]) for i in range(3)])
    max_abs_error_Int_G = np.max(np.abs(Int_G - Int_num_G))
    max_abs_error_Int_h_G = np.max(np.abs(Int_h_G - Int_num_h_G))
    max_abs_error_Int_grad_G = np.max(np.abs(Int_grad_G - Int_num_grad_G))
    max_abs_error_Int_h_grad_G = np.max(np.abs(Int_h_grad_G - I_num_h_grad_G))
    max_abs_error_Int_n_grad_G = np.max(np.abs(Int_n_grad_G - Int_num_n_grad_G))
    max_abs_error_Int_h_n_grad_G = np.max(np.abs(Int_h_n_grad_G - Int_num_h_n_grad_G))
    
    # plot setup
    fontsize = 8 
    fig, axs = plt.subplots(2, 4, figsize=(14, 7))
    title = 'Output' + evaluation_case
    fig.canvas.manager.set_window_title(title)
    plt.tight_layout()
    info_plot = axs[0, 0]
    info_plot.axis('off')
    width_wrap = 47
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
    
    # Add title text and info
    info_plot.text(
        0.5, 1.0,
        "Info",
        transform=info_plot.transAxes,
        fontsize=13,
        ha='center',
        va='center',
        weight='bold'
    )
    
    info_plot.text(
        0.1, 0.9,
        "Case:",
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left',  
        va='center',
        style='italic'
    )
    
    case = textwrap.fill("Line " + evaluation_case, width=width_wrap)
    info_plot.text(
        0.1, 0.83,
        case,
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left', 
        va='top',  
        bbox=props
    )

    # Add computation times to the info plot
    analytic_time_text = f"Analytic computation time:\n{time_analytical:.2e} seconds"
    numerical_time_text = f"Numerical computation time:\n{time_numerical:.2e} seconds"
    
    info_plot.text(
        0.1, 0.6,
        analytic_time_text,
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left',
        va='center',
        bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.5)
    )
    
    info_plot.text(
        0.1, 0.45,
        numerical_time_text,
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left',
        va='center',
        bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5)
    )
    
    h_info = "h is a linear function on the triangle with the value 1 at one corner and 0 on the others."
    wrapped_text = textwrap.fill(h_info, width=width_wrap)
    info_plot.text(
        0.1, 0.30,
        wrapped_text,
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left',  
        va='center',
        bbox=props
    )
    
    # Add additional text if evaluation_case contains a 6 or 7
    if '6' in evaluation_case or '7' in evaluation_case:
        additional_text = "WARNING: Evaluation directly at a triangle boundary contains unresolved singularities for the tangential components of the gradient."
        wrapped_additional_text = textwrap.fill(additional_text, width=width_wrap)
        info_plot.text(
            0.1, 0.18,
            wrapped_additional_text,
            transform=info_plot.transAxes,
            fontsize=8,
            ha='left',
            va='top',
            bbox=dict(boxstyle='round', facecolor='red', alpha=0.5)
        )

    # create all plots
    create_analysis_plot(axs[0, 1], r"$\int_T \ G(x,y) dA_y = \int_T \ \frac{1}{|y-x|} dA_y$", running_parameter, Int_G, Int_num_G, max_abs_error_Int_G, error_threshhold, fontsize)
    create_analysis_plot(axs[1, 1], r"$\int_T \ h(x) \ G(x,y) dA_y = \int_T \ h(x) \ \frac{1}{|y-x|} dA_y$", running_parameter, Int_h_G, Int_num_h_G, max_abs_error_Int_h_G, error_threshhold, fontsize)
    create_analysis_plot(axs[0, 2], r"$\int_T \ \partial_{n_y} G(x,y) dA_y = \int_T \ \langle n_y , \nabla \frac{1}{|y-x|} \rangle dA_y$", running_parameter, Int_n_grad_G, Int_num_n_grad_G, max_abs_error_Int_n_grad_G, error_threshhold, fontsize)
    create_analysis_plot(axs[1, 2], r"$\int_T \ h(x) \ \partial_{n_y} G(x,y) dA_y = \int_T \ h(x) \ \langle n_y , \nabla \frac{1}{|y-x|} \rangle dA_y$", running_parameter, Int_h_n_grad_G, Int_num_h_n_grad_G, max_abs_error_Int_h_n_grad_G, error_threshhold, fontsize)
    create_analysis_plot(axs[0, 3], r"$\int_T \ \nabla G(x,y) dA_y = \int_T \ \nabla \frac{1}{|y-x|} dA_y$", running_parameter, Int_grad_G, Int_num_grad_G, max_abs_error_Int_grad_G, error_threshhold, fontsize)
    create_analysis_plot(axs[1, 3], r"$\int_T \ h(x) \ \nabla G(x,y) dA_y = \int_T \ h(x) \ \nabla \frac{1}{|y-x|} dA_y$", running_parameter, Int_h_grad_G, I_num_h_grad_G, max_abs_error_Int_h_grad_G, error_threshhold, fontsize)
    
    # Plot the triangle
    plot_3d_view = axs[1, 0]
    plot_3d_view.set_axis_off()
    plot_3d_view_sub = fig.add_subplot(2, 4, 5, projection='3d')
    plot_3d_view_sub.set_title("Triangle Geometry & Evaluation Line", fontsize=fontsize, fontweight='bold')
    tri_faces = np.array([[0, 1, 2]])
    plot_3d_view_sub.plot_trisurf(triangle[:,0], triangle[:,1], triangle[:,2],
        triangles=tri_faces,
        color='r', edgecolor='k', alpha=0.5)
    
    # highlight the middle point
    mid_index = len(evaluation_line) // 2
    mid_point = evaluation_line[mid_index]    
    plot_3d_view_sub.scatter(mid_point[0], mid_point[1], mid_point[2], c='black', marker='*', s=20, label='Mid Point')
    plot_3d_view_sub.scatter(mid_point[0], mid_point[1], mid_point[2], c='white', marker='*', s=3)
    
    # darw the line
    for j in range(len(evaluation_line) - 1):
        plot_3d_view_sub.plot(
            evaluation_line[j:j+2, 0], 
            evaluation_line[j:j+2, 1], 
            evaluation_line[j:j+2, 2], 
            color=plt.cm.rainbow(j / len(evaluation_line)), 
            linewidth=1,
            label='Evaluation Line' if j == 0 else ""
        )
    
    # settings
    plot_3d_view_sub.view_init(elev=20, azim=30)
    plot_3d_view_sub.set_box_aspect([1,1,1])
    plot_3d_view_sub.legend(fontsize=fontsize)
    plt.tight_layout()

    # Enforce the same scale in all directions
    max_range = np.ptp(triangle, axis=0).max()
    mid = triangle.mean(axis=0)
    plot_3d_view_sub.set_xlim(mid[0] - max_range/2, mid[0] + max_range/2)
    plot_3d_view_sub.set_ylim(mid[1] - max_range/2, mid[1] + max_range/2)
    plot_3d_view_sub.set_zlim(mid[2] - max_range/2, mid[2] + max_range/2)

    # Label the axes
    plot_3d_view_sub.set_xlabel('X')
    plot_3d_view_sub.set_ylabel('Y')
    plot_3d_view_sub.set_zlabel('Z')
    
    # save as a figure in the target folder
    save_path = os.path.join(target_folder, f"{evaluation_case}.jpg")
    save_path = save_path.replace("(", "").replace(")", "").replace(" ", "_")
    fig.savefig(save_path, format='jpg', dpi=300)
    plt.close(fig)

# Used for each subplot of each integral type
def create_analysis_plot(plot_curr, title, running_parameter, analytic_data, numerical_data, max_abs_error, error_threshhold, fontsize):
    
    fontsize_labels = 6
    fontsize_axii = 8
    linewidth_analytic = 1.0
    linewidth_numeric = 3.0
    plot_curr.set_title(title, fontsize=9, fontweight='bold')
    
    # Plot the data
    if analytic_data.ndim == 1:
        # one dimensional data
        plot_curr.plot(running_parameter, numerical_data, label='Numerical', color='pink', linewidth=linewidth_numeric)
        plot_curr.plot(running_parameter, analytic_data, label='Analytic', linestyle='--', color='darkviolet',linewidth=linewidth_analytic)
        
    else:
        # vector data
        labels = ['x', 'y', 'z']
        colors = ['red', 'green', 'blue']
        colors_2 = [mcolors.hsv_to_rgb((0, 0.2, 1.0)), mcolors.hsv_to_rgb((1.0/3, 0.3, 1.0)), mcolors.hsv_to_rgb((2.0/3, 0.2, 1.0))]
        for i in range(analytic_data.shape[1]):
            plot_curr.plot(running_parameter, numerical_data[:, i], label=f'Numerical {labels[i]}', color=colors_2[i], linewidth=linewidth_numeric)
            plot_curr.plot(running_parameter, analytic_data[:, i], label=f'Analytic {labels[i]}', linestyle='--', color=colors[i], linewidth=linewidth_analytic)
    
    # settings
    plot_curr.set_xlabel('normal coordinate', fontsize=fontsize_axii, loc='left')
    plot_curr.set_ylabel('integration result', fontsize=fontsize_axii)
    plot_curr.tick_params(axis='both', which='major', labelsize=fontsize_axii)
    plot_curr.legend(fontsize=fontsize_labels)
    plot_curr.grid(True, which='both', color='lightgray', linestyle='-', linewidth=0.5)
    
    # print error
    if max_abs_error < error_threshhold:
        color = 'green'
        status = "success"
        props = dict(boxstyle='round', facecolor='white', edgecolor='green', linewidth=0.9)
    else:
        color = 'red'
        status = "failure at singularity"
    props = dict(boxstyle='round', facecolor='white', edgecolor=color, linewidth=0.9)
    plot_curr.text(0.98 , -0.13, f"Max abs error: {max_abs_error:.2e}", transform=plot_curr.transAxes, fontsize=fontsize, ha='right', bbox=props)
    plot_curr.text(0.5, 0.02, status, transform=plot_curr.transAxes, fontsize=fontsize, ha='center', va="bottom", bbox=props)


def open_clean_folder(name):
    """
    Create a clean folder. If it exists, delete its contents. Open the folder using the OS file explorer.
    """
    
    # If the folder does not exist, create it
    if not os.path.exists(name):
        os.makedirs(name)
    else:
        # If the folder exists, delete its contents
        for filename in os.listdir(name):
            file_path = os.path.join(name, filename)
            try:
                if os.path.isfile(file_path) or os.path.islink(file_path):
                    os.unlink(file_path)
                elif os.path.isdir(file_path):
                    shutil.rmtree(file_path)
            except Exception as e:
                print(f'Failed to delete {file_path}. Reason: {e}')

    # open by OS
    if platform.system() == "Windows":
        os.startfile(name)
    elif platform.system() == "Darwin":
        subprocess.Popen(["open", name])
    else:
        subprocess.Popen(["xdg-open", name])

if __name__ == "__main__":
    main()
