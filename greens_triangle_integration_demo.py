#!/usr/bin/env python3
"""
We compute analytically the Green's and its gradient and product with linear functions on a triangle T in R3.

Let x be an evaluation point, r(x,y) = |y-x| and Let h(x) be a linear function on the triangle with value 1 at the first triangle vertex and 0 on the other vertices.

We compute the following integrals 
  ‚à´ 1/r
  ‚à´ h ‚ãÖ 1/r
  ‚à´ <n, ‚àá(1/r)>
  ‚à´ h ‚ãÖ <n, ‚àá(1/r)>
  ‚à´ ‚àá(1/r)
  ‚à´ h ‚ãÖ ‚àá(1/r)
over a single triangle T in R3. 

An abitrary triangle is generated by the vertices triangle[0], triangle[1], triangle[2].
A wide selection of test evaluation points are generated.
The analytic computation is performed based on [Graglia]'s results.
The a numerical integration is performed via scipy.integrate.dblquad.
The results are compared and plotted in detail and saved into a folder in your working directory.

The test evaluation points are lines going through:
    - a point further outside of the triangle plane
    - a point in the triangle plane but not in the triangle or along an extended edge
    - a point on the extended edge of a triangle
    - a point on the extended edge of a triangle but off the other direction
    - a point in the triangle but not on an edge
    - a point on an edge but not a vertex
    - a triangle vertex (the first one, where h=1)    

The following reference was the base for the formulae in this code:
[Graglia] R. D. Graglia, "Numerical Integration of the Linear Shape Functions Times the 3-D Green's Function
or Its Gradient on a Plane Triangle," IEEE Transactions on Antennas and Propagation, 
vol. 41, no. 10, pp. 1448‚Äì1455, Oct. 1993.

The formulas have been adjusted to not require a transformation into the local triangle frame.
Additionally, an orientation dependant singularity issue on the extended edge of a triangle has been fixed.

Important note: When an evaluation point is at the boundary of the triangle, the tangential part of the gradient integrals become singular.

"""

import numpy as np
import os
import platform
import shutil
import subprocess
import textwrap
import time
import warnings

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from scipy.integrate import dblquad

# -----------------------------------------------------------------------------
### Settings ###
line_resolution = 51
accuracy_treshold = 1e-6
target_folder = "integration_results"
# -----------------------------------------------------------------------------


def main():

    print("\n üèÅ Start üèÅ")

    # ---------------------------------------------------------------------
    # 1) Define the demo triangle
    # ---------------------------------------------------------------------

    simple_triangle = np.array([[0.0, 0, 0],
                  [1, 0, 0],
                  [0, 1, 0]])
    
    arbitrary_triangle = np.array([
        [0.0, -1.0, 1.0],
        [1.0, 0.0, 0.0],
        [-1.0, 2.5, 0.0]
    ])
    
    random_triangle = np.random.rand(3, 3)
    
    # pick a triangle
    triangle = arbitrary_triangle

    
    # ---------------------------------------------------------------------
    # 2) Define evaluation lines
    # ---------------------------------------------------------------------

    # initialize 
    n_evaluation_points = line_resolution + (1-line_resolution % 2) # make sure it is odd
    evaluation_cases = []; evaluation_lines = []
    running_parameter = np.linspace(-1, 1, n_evaluation_points)*.5
    triangle_normal = get_normal_from_triangle(triangle)
    evaluation_base_line = np.outer(running_parameter, triangle_normal)
    triangle_corner = triangle[0]
    triangle_edge_1 = triangle[1]-triangle[0]
    triangle_edge_2 = triangle[2]-triangle[0]
    
    # go through every evaluation case, comment out if you dont want to evaluate
    evaluation_cases.append("(1) outside of the triangle plane")
    line_center = triangle_corner + 0.3 * triangle_edge_1 + 0.3 * triangle_edge_2 + 1.5 * triangle_normal
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(2) in the triangle plane but not in the triangle or along an extended edge")
    line_center = triangle_corner + 0.6 * triangle_edge_1 + 0.5 * triangle_edge_2
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(3) on the extended edge of a triangle")
    line_center = triangle_corner + 1.1 * triangle_edge_1
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(4) on the extended edge of a triangle but off the other direction")
    line_center = triangle_corner - 0.1 * triangle_edge_1
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(5) in the triangle but not on an edge")
    line_center = triangle_corner + triangle_edge_1*0.3 + triangle_edge_2*0.2
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(6) through a point on an edge")
    line_center = triangle_corner + triangle_edge_1*0.3
    evaluation_lines.append(line_center + evaluation_base_line)
    
    evaluation_cases.append("(7) through a triangle vertex")
    line_center = triangle_corner
    evaluation_lines.append(line_center + evaluation_base_line)
    
    
    

    # ---------------------------------------------------------------------
    # 3) Compute the triangle integrals (analytically + numerically)
    # ---------------------------------------------------------------------
    
    # comment in if you want to just evaluate one case
    # case_index = 0
    # evaluation_lines = [evaluation_lines[case_index]]
    # evaluation_cases = [evaluation_cases[case_index]]
    
    open_clean_folder(target_folder)

    # Loop over all cases
    for i in range(len(evaluation_lines)):
        
        # read
        evaluation_case = evaluation_cases[i]
        evaluation_line = evaluation_lines[i]
        print("\nEvaluating "+ evaluation_case)
        
        # analytic integration
        I, I_linear, I_grad, I_grad_linear, I_n_grad, I_n_grad_linear, end_time_analytic = greens_analytic_integration(evaluation_line, triangle)

        # numerical integration
        I_num, I_num_linear, I_num_grad, I_num_grad_linear, I_num_n_grad, I_num_n_grad_linear, end_time_numerical = greens_numeric_integration(evaluation_line, triangle)
        
        # Analyze results
        results_analytical = [I, I_linear, I_grad, I_grad_linear, I_n_grad, I_n_grad_linear, end_time_analytic]
        results_numerical = [I_num, I_num_linear, I_num_grad, I_num_grad_linear, I_num_n_grad, I_num_n_grad_linear, end_time_numerical]
        analyze_results(results_analytical, results_numerical, evaluation_line, triangle, running_parameter, evaluation_case)
        

    print("\n üö© End üö© \n")


# -----------------------------------------------------------------------------
# Analytic integrator
# -----------------------------------------------------------------------------

def greens_analytic_integration(P_observer, P_triangle):
    """
    Integrates '1/r' and 'grad(1/r)' over a single plane triangle in 3D.

    Returns
    -------
    I1 : ndarray of shape (nfp,)
        Integral of 1/r over the triangle for each field point.
    Igrad : ndarray of shape (nfp, 3)
        Integral of grad(1/r) over the triangle for each field point.
    """
    start_time = time.perf_counter()
    print("Analytic  integration...", end='')
    
    nr_observation_points = P_observer.shape[0]

    # remap origin
    P_observer = P_observer - P_triangle[0]
    P_triangle = P_triangle - P_triangle[0]

    # Lengths and edge tangent vectors
    s = np.array([
        P_triangle[2] - P_triangle[1],
        P_triangle[0] - P_triangle[2],
        P_triangle[1] - P_triangle[0]
    ])
    l1, l2, l3 = np.linalg.norm(s, axis=1)
    s = normalize_rows(s)

    # normal and edge normals
    normal = get_normal_from_triangle(P_triangle)
    m = np.array([
        np.cross(s[0], normal),
        np.cross(s[1], normal),
        np.cross(s[2], normal)
    ])
    
    # triangle frame basis vectors
    u_unit = s[2]
    v_unit = -m[2]
    w_unit = normal

    # evaluation points coordinates in triangle frame
    u0 = np.dot( P_observer, u_unit )
    v0 = np.dot( P_observer, v_unit )
    w0 = np.dot( P_observer, w_unit )
    
    # parametrization of linear map
    u3 = np.dot( P_triangle[2] , u_unit )
    v3 = np.dot( P_triangle[2] , v_unit )
    form = np.array([
        [1, -1/l3, ( (u3 / l3) - 1 )/v3],
        [0,  1/l3, -u3 / ( l3*v3 )],
        [0,  0,  1]
    ])
    N10, N20, N30 = form @ [np.ones_like(u0), u0, v0]
    
    # Project observation points to the plane of the triangel
    P_plane = P_observer - np.dot( P_observer, w_unit )[:, np.newaxis] * w_unit
    
    # Project observation points to the edges of the triangle
    P_edge = np.zeros((nr_observation_points, 3, 3))
    for i in range(3):
        P_edge[:, i, :] = P_triangle[(i + 1) % 3] + s[i] * np.dot(P_observer - P_triangle[(i + 1) % 3], s[i])[:, np.newaxis]
    

    # parametrizations of integration
    splus = np.zeros((nr_observation_points, 3))
    sminus = np.zeros((nr_observation_points, 3))
    timer_start = np.zeros((nr_observation_points, 3))
    for i in range(3):
        splus[:, i] = np.dot( P_triangle[(i + 2) % 3] - P_edge[:, i, :] , s[i])
        sminus[:, i] = np.dot( P_triangle[(i + 1) % 3] - P_edge[:, i, :] , s[i])
        timer_start[:, i] = np.dot( P_edge[:, i, :] - P_plane , m[i])
    
    # distances
    R0 = np.linalg.norm(P_observer[:, np.newaxis, :] - P_edge, axis=2)
    Rplus = np.linalg.norm(P_observer[:, np.newaxis, :] - P_triangle[np.array([2, 0, 1])], axis=2)
    Rminus = np.linalg.norm(P_observer[:, np.newaxis, :] - P_triangle[np.array([1, 2, 0])], axis=2)
    
    # apply in plane treshhold 
    threshhold = accuracy_treshold * min([l1, l2, l3])
    timer_start[np.abs(timer_start) < threshhold] = 0.0
    w0[np.abs(w0) < threshhold] = 0.0
    R0[np.abs(R0) < threshhold] = 0.0
    w0_tile = np.tile(w0, (3,1)).T

    # side functions
    with np.errstate(divide='ignore', invalid='ignore'):
        f2 = np.log((Rplus + splus) / (Rminus + sminus))
        # the following line addresses a singularity issue on the extended edge of a triangle (a 0/0 error)
        f2 = np.where( (np.isnan(f2)) | (f2 < 0), np.log((Rminus - sminus) / (Rplus - splus)), f2)
        # next we acknowledge that on the triangle boundary we have an unresolved singularity that we simply remove.
        # It is only noticible in the tangential gradient.
        f2 = np.where( (np.isnan(f2)) | np.isinf(f2), 0, f2)
    f3 = (splus * Rplus - sminus * Rminus) + R0**2 * f2
    with np.errstate(divide='ignore', invalid='ignore'):
        betas = (np.arctan(timer_start * splus / (R0**2 + np.abs(w0_tile) * Rplus))
                - np.arctan(timer_start * sminus / (R0**2 + np.abs(w0_tile) * Rminus)))
        betas = np.where( R0 < threshhold, 0, betas)
        beta = np.sum( betas, axis=1 )
    
    # Basic integral of Green's function G
    
    # eq. (19): integral of 1/r
    I_const = np.sum(timer_start*f2 , axis=1) - np.abs(w0)*beta

    # eq. (20): integral of u or v times (1/r)
    sum_vector = 0.5 * f3 @ m
    Iua = np.dot( sum_vector , u_unit  )
    Iva = np.dot( sum_vector , v_unit  )

    # eq. (24): integral of linear map times (1/r)
    Iu = u0 * I_const + Iua
    Iv = v0 * I_const + Iva 
    # compute for the 3 linear basis functions on the triangle
    I0_linear, I1_linear, I2_linear = form @ [I_const, Iu, Iv]
    
    # Integral of the gradient of the Green's function G
    
    # eq. (34): integral of grad(1/r)
    Igrad = - f2 @ m - np.sign(w0)[:, np.newaxis] * beta[:, np.newaxis] * w_unit

    # eq. (36): integrals of u or v times grad(1/r)
    part1u = (w0 * np.dot((f2 @ m), u_unit))[:, None] * w_unit
    part1v = (w0 * np.dot((f2 @ m), v_unit))[:, None] * w_unit
    part2u = (-np.abs(w0) * beta)[:, None] * u_unit
    part2v = (-np.abs(w0) * beta)[:, None] * v_unit
    u_dot_s = np.sum(u_unit * s, axis=1)
    v_dot_s = np.sum(v_unit * s, axis=1)
    f = ( (f2 * timer_start)[:, :, None] * s[None, :, :]) - ((Rplus - Rminus)[:, :, None] * m[None, :, :])
    part3u = (f * u_dot_s[None, :, None]).sum(axis=1)
    part3v = (f * v_dot_s[None, :, None]).sum(axis=1)
    Igradua = part1u + part2u + part3u
    Igradva = part1v + part2v + part3v
    
    # eq. (40): integral of linear map times grad(1/r)
    Igradu = u0[:,np.newaxis] * Igrad + Igradua
    Igradv = v0[:,np.newaxis] * Igrad + Igradva
    # compute for the 3 linear basis functions on the triangle
    I0grad_linear = np.tensordot(form[0], [Igrad, Igradu, Igradv], axes=1)    
    I1grad_linear = np.tensordot(form[1], [Igrad, Igradu, Igradv], axes=1)
    I2grad_linear = np.tensordot(form[2], [Igrad, Igradu, Igradv], axes=1)

    # Integral of the normal gradient of the Green's function G

    # eq. (34): integral of <n , grad(1/r) >
    I_n_grad = -np.sign(w0) * beta
    
    # eq. (40): integrals of linear map times <n , grad(1/r) >
    I_n_grad_linear = form[0] @ [
        (-np.sign(w0) * beta * N10),
        (w0 * np.dot(f2 @ m, u_unit)),
        (w0 * np.dot(f2 @ m, v_unit))
    ]

    # time
    time_passed = time.perf_counter() - start_time
    print(f" {time_passed:.2e} seconds")

    # final return
    return I_const, I0_linear, Igrad, I0grad_linear, I_n_grad, I_n_grad_linear, time_passed

# -----------------------------------------------------------------------------
# Numerical integration
# -----------------------------------------------------------------------------

# wrapper function to call and time all numerical integrals
def greens_numeric_integration(evaluation_points,triangle):
    
    start_time = time.perf_counter()
    print("Numerical integration...", end='')
    
    I_num = greens_numeric_integration_G(evaluation_points, triangle)
    I_num_linear = greens_numeric_integration_h_G(evaluation_points, triangle)
    I_num_grad = greens_numeric_integration_grad_G(evaluation_points, triangle)
    I_num_grad_linear = greens_numeric_integration_h_grad_G(evaluation_points, triangle)
    I_num_n_grad = greens_numeric_integration_n_grad_G(evaluation_points, triangle)
    I_num_n_grad_linear = greens_numeric_integration_h_n_grad_G(evaluation_points, triangle)
    
    time_passed = time.perf_counter() - start_time
    print(f" {time_passed:.2e} seconds")
    
    return I_num, I_num_linear, I_num_grad, I_num_grad_linear, I_num_n_grad, I_num_n_grad_linear, time_passed

def greens_numeric_integration_G(evaluation_points, triangle):
    """
    Numerically integrates 1/|y - x| over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """

    npt = evaluation_points.shape[0]
    I_const = np.zeros(npt)

    # Edges
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    Jac = np.linalg.norm(np.cross(v1, v2))

    for i in range(npt):
        qx, qy, qz = evaluation_points[i]

        def integrand_1overr(v, u):
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx*dx + dy*dy + dz*dz)
            return Jac / r

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val_const, _ = dblquad(
                integrand_1overr,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
        I_const[i] = val_const

    return I_const

def greens_numeric_integration_h_G(evaluation_points, triangle):
    """
    Numerically integrates h ‚ãÖ 1/|y - x| over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """

    npt = evaluation_points.shape[0]
    I_lin = np.zeros(npt)

    # Edges as before
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    Jac = np.linalg.norm(np.cross(v1, v2))

    for i in range(npt):
        qx, qy, qz = evaluation_points[i]

        # The integrand now includes (1 - u - v)
        def integrand_1overr(v, u):
            # Param for the triangle
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx*dx + dy*dy + dz*dz)

            shape0 = 1.0 - u - v  # the shape function for node 0
            return (Jac * shape0) / r

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val_lin, _ = dblquad(
                integrand_1overr,
                0.0, 1.0,           
                lambda u: 0.0,      
                lambda u: 1.0 - u   
            )
        I_lin[i] = val_lin

    return I_lin

def greens_numeric_integration_grad_G(evaluation_points, triangle):
    """
    Numerically integrates ‚àá( 1/|y - x| ) over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """
    npt = evaluation_points.shape[0]

    # Prepare the output array for the 3 components
    I_grad = np.zeros((npt, 3))

    # Precompute vectors for parameterization
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    # The Jacobian factor for surface area
    Jac = np.linalg.norm(np.cross(v1, v2))
    
    # Loop over each observer point
    for i in range(npt):
        qx, qy, qz = evaluation_points[i]

        def integrand_gradx(v, u):
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx*dx + dy*dy + dz*dz)
            return -(dx / r**3) * Jac 

        def integrand_grady(v, u):
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx*dx + dy*dy + dz*dz)
            return -(dy / r**3) * Jac

        def integrand_gradz(v, u):
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx*dx + dy*dy + dz*dz)
            return -(dz / r**3) * Jac

        # Now do 3 separate dblquad calls
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")

            valx, _ = dblquad(
                integrand_gradx,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            valy, _ = dblquad(
                integrand_grady,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            valz, _ = dblquad(
                integrand_gradz,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )

        I_grad[i, 0] = valx
        I_grad[i, 1] = valy
        I_grad[i, 2] = valz

    return I_grad

def greens_numeric_integration_h_grad_G(evaluation_points, triangle):
    """
    Numerically integrates h ‚ãÖ ‚àá( 1/|y - x| ) over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """
    npt = evaluation_points.shape[0]

    # Prepare the output array for the 3 components
    I_grad = np.zeros((npt, 3))

    # Precompute vectors for parameterization
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    # The surface area factor
    Jac = np.linalg.norm(np.cross(v1, v2))

    for i in range(npt):
        qx, qy, qz = evaluation_points[i]

        def integrand_gradx(v, u):
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            # small regularization to avoid r=0 blowups
            r = np.sqrt(dx*dx + dy*dy + dz*dz)

            # shape function for node V[0]
            shape0 = 1.0 - u - v
            # combine with -(dx/r^3), plus the area factor
            return shape0 * (-(dx / r**3)) * Jac

        def integrand_grady(v, u):
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx*dx + dy*dy + dz*dz)

            shape0 = 1.0 - u - v
            return shape0 * (-(dy / r**3)) * Jac

        def integrand_gradz(v, u):
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx*dx + dy*dy + dz*dz)

            shape0 = 1.0 - u - v
            return shape0 * (-(dz / r**3)) * Jac

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")

            valx, _ = dblquad(
                integrand_gradx,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            valy, _ = dblquad(
                integrand_grady,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
            valz, _ = dblquad(
                integrand_gradz,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )

        I_grad[i, 0] = valx
        I_grad[i, 1] = valy
        I_grad[i, 2] = valz

    return I_grad

def greens_numeric_integration_n_grad_G(evaluation_points,triangle):
    """
    Numerically integrates < n , ‚àá( 1/|y - x| ) > over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """

    npt = evaluation_points.shape[0]

    # Prepare the output array
    I_grad_dot_n = np.zeros(npt)

    # Precompute vectors for parameterization
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    # The Jacobian factor for surface area
    Jac = np.linalg.norm(np.cross(v1, v2))

    # Get the normal vector of the triangle
    normal = get_normal_from_triangle(triangle)

    # Loop over each observer point
    for i in range(npt):
        qx, qy, qz = evaluation_points[i]

        def integrand(v, u):
            Y = triangle[0] + u * v1 + v * v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx * dx + dy * dy + dz * dz)
            grad = np.array([dx, dy, dz]) / r**3
            return -np.dot(normal, grad) * Jac

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val, _ = dblquad(
                integrand,
                0.0, 1.0,
                lambda u: 0.0,
                lambda u: 1.0 - u
            )
        I_grad_dot_n[i] = val

    return I_grad_dot_n

def greens_numeric_integration_h_n_grad_G(evaluation_points, triangle):
    """
    Numerically integrates h ‚ãÖ < n , ‚àá( 1/|y - x| ) > over the triangle spanned by 
    triangle[0], triangle[1], triangle[2].
    """

    npt = evaluation_points.shape[0]
    I_grad_dot_n = np.zeros(npt)

    # -----------------------------------------------------
    # 1) Parameterization / geometry setup
    # -----------------------------------------------------
    v1 = triangle[1] - triangle[0]
    v2 = triangle[2] - triangle[0]
    # Triangle area scaling factor = ||v1 x v2||
    Jac = np.linalg.norm(np.cross(v1, v2))
    normal = get_normal_from_triangle(triangle)


    # -----------------------------------------------------
    # 2) Integration loop over each observer point
    # -----------------------------------------------------
    for i in range(npt):
        qx, qy, qz = evaluation_points[i]

        def integrand_1overr_dot_n(v, u):
            # Parametric point Y(u,v) in the triangle
            Y = triangle[0] + u*v1 + v*v2
            dx = qx - Y[0]
            dy = qy - Y[1]
            dz = qz - Y[2]
            r = np.sqrt(dx*dx + dy*dy + dz*dz)
            grad_dot_n = -(dx*normal[0] + dy*normal[1] + dz*normal[2]) / (r**3)

            # shape function for node V[0] => (1 - u - v)
            shape0 = 1.0 - u - v

            # Multiply by area factor
            return grad_dot_n * shape0 * Jac

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            val, _ = dblquad(
                integrand_1overr_dot_n,
                0.0, 1.0,                # u goes 0..1
                lambda u: 0.0,           # v min
                lambda u: 1.0 - u        # v max
            )

        I_grad_dot_n[i] = val

    return I_grad_dot_n

# -----------------------------------------------------------------------------
# Analyzing functions
# -----------------------------------------------------------------------------

# Compute errors and plot results comparing the analytical and numerical integrals
def analyze_results(results_analytical, results_numerical, evaluation_line, triangle, running_parameter, evaluation_case):
    
    # read
    I, I_linear, I_grad, I_grad_linear, I_n_grad, I_n_grad_linear, time_analytical = results_analytical
    I_num, I_num_linear, I_num_grad, I_num_grad_linear, I_num_n_grad, I_num_n_grad_linear, time_numerical = results_numerical
    
    # error measures
    error_threshhold = accuracy_treshold*np.min([np.linalg.norm(triangle[i] - triangle[(i+1) % 3]) for i in range(3)])
    max_abs_error_I = np.max(np.abs(I - I_num))
    max_abs_error_I_linear = np.max(np.abs(I_linear - I_num_linear))
    max_abs_error_I_grad = np.max(np.abs(I_grad - I_num_grad))
    max_abs_error_I_grad_linear = np.max(np.abs(I_grad_linear - I_num_grad_linear))
    max_abs_error_I_n_grad = np.max(np.abs(I_n_grad - I_num_n_grad))
    max_abs_error_I_n_grad_linear = np.max(np.abs(I_n_grad_linear - I_num_n_grad_linear))
    
    # plot setup
    fontsize = 8 
    fig, axs = plt.subplots(2, 4, figsize=(14, 7))
    title = 'Output' + evaluation_case
    fig.canvas.manager.set_window_title(title)
    plt.tight_layout()
    info_plot = axs[0, 0]
    info_plot.axis('off')
    width_wrap = 47
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
    
    # Add title text and info
    info_plot.text(
        0.5, 1.0,
        "Info",
        transform=info_plot.transAxes,
        fontsize=13,
        ha='center',
        va='center',
        weight='bold'
    )
    
    info_plot.text(
        0.1, 0.9,
        "Case:",
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left',  
        va='center',
        style='italic'
    )
    
    case = textwrap.fill("Line " + evaluation_case, width=width_wrap)
    info_plot.text(
        0.1, 0.83,
        case,
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left', 
        va='top',  
        bbox=props
    )

    # Add computation times to the info plot
    analytic_time_text = f"Analytic computation time:\n{time_analytical:.2e} seconds"
    numerical_time_text = f"Numerical computation time:\n{time_numerical:.2e} seconds"
    
    info_plot.text(
        0.1, 0.6,
        analytic_time_text,
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left',
        va='center',
        bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.5)
    )
    
    info_plot.text(
        0.1, 0.45,
        numerical_time_text,
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left',
        va='center',
        bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5)
    )
    
    h_info = "h is a linear function on the triangle with the value 1 at one corner and 0 on the others."
    wrapped_text = textwrap.fill(h_info, width=width_wrap)
    info_plot.text(
        0.1, 0.30,
        wrapped_text,
        transform=info_plot.transAxes,
        fontsize=8,
        ha='left',  
        va='center',
        bbox=props
    )
    
    # Add additional text if evaluation_case contains a 6 or 7
    if '6' in evaluation_case or '7' in evaluation_case:
        additional_text = "WARNING: Evaluation directly at a triangle boundary contains unresolved singularities for the tangential components of the gradient."
        wrapped_additional_text = textwrap.fill(additional_text, width=width_wrap)
        info_plot.text(
            0.1, 0.18,
            wrapped_additional_text,
            transform=info_plot.transAxes,
            fontsize=8,
            ha='left',
            va='top',
            bbox=dict(boxstyle='round', facecolor='red', alpha=0.5)
        )

    # create all plots
    create_analysis_plot(axs[0, 1], r"$\int_T \ G(x,y) dA_y = \int_T \ \frac{1}{|y-x|} dA_y$", running_parameter, I, I_num, max_abs_error_I, error_threshhold, fontsize)
    create_analysis_plot(axs[1, 1], r"$\int_T \ h(x) \ G(x,y) dA_y = \int_T \ h(x) \ \frac{1}{|y-x|} dA_y$", running_parameter, I_linear, I_num_linear, max_abs_error_I_linear, error_threshhold, fontsize)
    create_analysis_plot(axs[0, 2], r"$\int_T \ \partial_{n_y} G(x,y) dA_y = \int_T \ \langle n_y , \nabla \frac{1}{|y-x|} \rangle dA_y$", running_parameter, I_n_grad, I_num_n_grad, max_abs_error_I_n_grad, error_threshhold, fontsize)
    create_analysis_plot(axs[1, 2], r"$\int_T \ h(x) \ \partial_{n_y} G(x,y) dA_y = \int_T \ h(x) \ \langle n_y , \nabla \frac{1}{|y-x|} \rangle dA_y$", running_parameter, I_n_grad_linear, I_num_n_grad_linear, max_abs_error_I_n_grad_linear, error_threshhold, fontsize)
    create_analysis_plot(axs[0, 3], r"$\int_T \ \nabla G(x,y) dA_y = \int_T \ \nabla \frac{1}{|y-x|} dA_y$", running_parameter, I_grad, I_num_grad, max_abs_error_I_grad, error_threshhold, fontsize)
    create_analysis_plot(axs[1, 3], r"$\int_T \ h(x) \ \nabla G(x,y) dA_y = \int_T \ h(x) \ \nabla \frac{1}{|y-x|} dA_y$", running_parameter, I_grad_linear, I_num_grad_linear, max_abs_error_I_grad_linear, error_threshhold, fontsize)
    
    # Plot the triangle
    plot_3d_view = axs[1, 0]
    plot_3d_view.set_axis_off()
    plot_3d_view_sub = fig.add_subplot(2, 4, 5, projection='3d')
    plot_3d_view_sub.set_title("Triangle Geometry & Evaluation Line", fontsize=fontsize, fontweight='bold')
    tri_faces = np.array([[0, 1, 2]])
    plot_3d_view_sub.plot_trisurf(triangle[:,0], triangle[:,1], triangle[:,2],
        triangles=tri_faces,
        color='r', edgecolor='k', alpha=0.5)
    
    # highlight the middle point
    mid_index = len(evaluation_line) // 2
    mid_point = evaluation_line[mid_index]    
    plot_3d_view_sub.scatter(mid_point[0], mid_point[1], mid_point[2], c='black', marker='*', s=20, label='Mid Point')
    plot_3d_view_sub.scatter(mid_point[0], mid_point[1], mid_point[2], c='white', marker='*', s=3)
    
    # darw the line
    for j in range(len(evaluation_line) - 1):
        plot_3d_view_sub.plot(
            evaluation_line[j:j+2, 0], 
            evaluation_line[j:j+2, 1], 
            evaluation_line[j:j+2, 2], 
            color=plt.cm.rainbow(j / len(evaluation_line)), 
            linewidth=1,
            label='Evaluation Line' if j == 0 else ""
        )
    
    # settings
    plot_3d_view_sub.view_init(elev=20, azim=30)
    plot_3d_view_sub.set_box_aspect([1,1,1])
    plot_3d_view_sub.legend(fontsize=fontsize)
    plt.tight_layout()

    # Enforce the same scale in all directions
    max_range = np.ptp(triangle, axis=0).max()
    mid = triangle.mean(axis=0)
    plot_3d_view_sub.set_xlim(mid[0] - max_range/2, mid[0] + max_range/2)
    plot_3d_view_sub.set_ylim(mid[1] - max_range/2, mid[1] + max_range/2)
    plot_3d_view_sub.set_zlim(mid[2] - max_range/2, mid[2] + max_range/2)

    # Label the axes
    plot_3d_view_sub.set_xlabel('X')
    plot_3d_view_sub.set_ylabel('Y')
    plot_3d_view_sub.set_zlabel('Z')
    
    # save as a figure in the target folder
    save_path = os.path.join(target_folder, f"{evaluation_case}.jpg")
    save_path = save_path.replace("(", "").replace(")", "").replace(" ", "_")
    fig.savefig(save_path, format='jpg', dpi=300)
    plt.close(fig)

# Used for each subplot of each integral type
def create_analysis_plot(plot_curr, title, running_parameter, analytic_data, numerical_data, max_abs_error, error_threshhold, fontsize):
    
    fontsize_labels = 6
    fontsize_axii = 8
    linewidth_analytic = 1.0
    linewidth_numeric = 3.0
    plot_curr.set_title(title, fontsize=9, fontweight='bold')
    
    # Plot the data
    if analytic_data.ndim == 1:
        # one dimensional data
        plot_curr.plot(running_parameter, numerical_data, label='Numerical', color='pink', linewidth=linewidth_numeric)
        plot_curr.plot(running_parameter, analytic_data, label='Analytic', linestyle='--', color='darkviolet',linewidth=linewidth_analytic)
        
    else:
        # vector data
        labels = ['x', 'y', 'z']
        colors = ['red', 'green', 'blue']
        colors_2 = [mcolors.hsv_to_rgb((0, 0.2, 1.0)), mcolors.hsv_to_rgb((1.0/3, 0.3, 1.0)), mcolors.hsv_to_rgb((2.0/3, 0.2, 1.0))]
        for i in range(analytic_data.shape[1]):
            plot_curr.plot(running_parameter, numerical_data[:, i], label=f'Numerical {labels[i]}', color=colors_2[i], linewidth=linewidth_numeric)
            plot_curr.plot(running_parameter, analytic_data[:, i], label=f'Analytic {labels[i]}', linestyle='--', color=colors[i], linewidth=linewidth_analytic)
    
    # settings
    plot_curr.set_xlabel('normal coordinate', fontsize=fontsize_axii, loc='left')
    plot_curr.set_ylabel('integration result', fontsize=fontsize_axii)
    plot_curr.tick_params(axis='both', which='major', labelsize=fontsize_axii)
    plot_curr.legend(fontsize=fontsize_labels)
    plot_curr.grid(True, which='both', color='lightgray', linestyle='-', linewidth=0.5)
    
    # print error
    if max_abs_error < error_threshhold:
        color = 'green'
        status = "success"
        props = dict(boxstyle='round', facecolor='white', edgecolor='green', linewidth=0.9)
    else:
        color = 'red'
        status = "failure at singularity"
    props = dict(boxstyle='round', facecolor='white', edgecolor=color, linewidth=0.9)
    plot_curr.text(0.98 , -0.13, f"Max abs error: {max_abs_error:.2e}", transform=plot_curr.transAxes, fontsize=fontsize, ha='right', bbox=props)
    plot_curr.text(0.5, 0.02, status, transform=plot_curr.transAxes, fontsize=fontsize, ha='center', va="bottom", bbox=props)

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------

def get_normal_from_triangle(V):
    """
    Computes the normal vector of a triangle defined by vertices V. This function is used to be consistent.
    """
    normal = np.cross(V[1] - V[0], V[2] - V[0])
    if np.linalg.norm(normal) < 1e-14:
        raise ValueError("The triangle is degenerate (vertices are collinear).")
    return normalize(normal)
    
def normalize(v):
    """ Return the unit (normalized) vector of v. """
    v = np.asarray(v, dtype=float)
    n = np.linalg.norm(v)
    return v / n if n > 1e-14 else v

def normalize_rows(matrix):
    """ Normalize each row of the input matrix. """
    norms = np.linalg.norm(matrix, axis=1, keepdims=True)
    norms = np.where(norms > 1e-14, norms, 1)
    return matrix / norms

def open_clean_folder(name):
    """
    Create a clean folder. If it exists, delete its contents. Open the folder using the OS file explorer.
    """
    
    # If the folder does not exist, create it
    if not os.path.exists(name):
        os.makedirs(name)
    else:
        # If the folder exists, delete its contents
        for filename in os.listdir(name):
            file_path = os.path.join(name, filename)
            try:
                if os.path.isfile(file_path) or os.path.islink(file_path):
                    os.unlink(file_path)
                elif os.path.isdir(file_path):
                    shutil.rmtree(file_path)
            except Exception as e:
                print(f'Failed to delete {file_path}. Reason: {e}')

    # open by OS
    if platform.system() == "Windows":
        os.startfile(name)
    elif platform.system() == "Darwin":
        subprocess.Popen(["open", name])
    else:
        subprocess.Popen(["xdg-open", name])

if __name__ == "__main__":
    main()
